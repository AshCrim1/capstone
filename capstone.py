# -*- coding: utf-8 -*-
"""capstone.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MrgKEwkKaB42xEpVM1SunTQ1q2aa7AVo
"""

!pip install qiskit qiskit-aer networkx scipy tqdm matplotlib seaborn pylatexenc
!pip install pandas numpy typing dataclasses

import numpy as np
import networkx as nx
import scipy.linalg
from qiskit.quantum_info import Statevector, Operator, DensityMatrix
import matplotlib.pyplot as plt
from typing import Dict, List, Tuple, Optional, Union

class QuantumBatteryNetwork:
    def __init__(self, num_batteries=4):
        self.num_batteries = num_batteries
        self.h = 1.0  # Fixed to balanced coupling
        self.k = 1.0  # Fixed to balanced coupling
        # Initialize with default path topology
        self.network = nx.path_graph(self.num_batteries)

        # Calculate and store the reference energy level (maximum energy state energy)
        max_state = self._prepare_max_energy_state_raw()
        # The reference (raw) energy is used to shift energies so that the max state has 0 energy.
        self.reference_energy = self._calculate_total_system_energy_raw(max_state)["total_energy"]

    def set_network_topology(self, topology='path'):
        if topology == 'path':
            self.network = nx.path_graph(self.num_batteries)
        elif topology == 'star':
            # Star network with center at node 0
            self.network = nx.star_graph(self.num_batteries - 1)
        elif topology == 'ring':
            # Ring network where last node connects to first
            self.network = nx.cycle_graph(self.num_batteries)
        else:
            raise ValueError(f"Unsupported topology: {topology}")

    def _prepare_max_energy_state_raw(self):
        # Calculate the state parameters for maximum energy state
        # For maximum energy state: |Emax⟩ = a|00⟩ + b|11⟩
        a = (1/np.sqrt(2)) * np.sqrt(1 - self.h/np.sqrt(self.h**2 + self.k**2))
        b = (1/np.sqrt(2)) * np.sqrt(1 + self.h/np.sqrt(self.h**2 + self.k**2))

        # Create max energy state for single battery
        single_battery_state = np.array([a, 0, 0, b])  # state vector in computational basis

        # Create tensor product state for all batteries
        state = single_battery_state
        for _ in range(1, self.num_batteries):
            state = np.kron(state, single_battery_state)

        # Convert to density matrix
        state_matrix = np.outer(state, np.conj(state))
        return DensityMatrix(state_matrix)

    def prepare_max_energy_state(self):
        return self._prepare_max_energy_state_raw()

    def prepare_ground_state(self):
        # Calculate the state parameters for ground state
        a = (1/np.sqrt(2)) * np.sqrt(1 - self.h/np.sqrt(self.h**2 + self.k**2))
        b = (1/np.sqrt(2)) * np.sqrt(1 + self.h/np.sqrt(self.h**2 + self.k**2))

        # Create ground state for single battery (note the minus sign)
        single_battery_state = np.array([a, 0, 0, -b])  # |g⟩ = a|00⟩ - b|11⟩

        # Create tensor product state for all batteries
        state = single_battery_state
        for _ in range(1, self.num_batteries):
            state = np.kron(state, single_battery_state)

        # Convert to density matrix
        state_matrix = np.outer(state, np.conj(state))
        return DensityMatrix(state_matrix)

    def alice_measurement_operator(self, battery_idx, result):
        q1 = 2 * battery_idx  # Alice's qubit in the battery
        total_qubits = 2 * self.num_batteries

        # Projection operators for the X basis
        if result == 0:
            proj_op = np.array([[0.5, 0.5], [0.5, 0.5]])  # |+⟩⟨+|
        else:
            proj_op = np.array([[0.5, -0.5], [-0.5, 0.5]])  # |-⟩⟨-|

        # Construct full operator on all qubits
        ops = [np.eye(2)] * total_qubits
        ops[q1] = proj_op

        full_op = ops[0]
        for op in ops[1:]:
            full_op = np.kron(full_op, op)
        return Operator(full_op)

    def bob_operation_operator(self, battery_idx, result):
        q2 = 2 * battery_idx + 1  # Bob's qubit (the second qubit in the battery)
        total_qubits = 2 * self.num_batteries

        # Calculate optimal angle phi for h=1, k=1
        h2_plus_2k2 = self.h**2 + 2 * self.k**2
        h2k2 = self.h**2 * self.k**2
        cos_2phi = h2_plus_2k2 / np.sqrt((h2_plus_2k2)**2 + h2k2)
        sin_2phi = self.h * self.k / np.sqrt((h2_plus_2k2)**2 + h2k2)
        phi = np.arctan2(sin_2phi, cos_2phi) / 2

        # Convert measurement result to mu: 0-> +1, 1-> -1
        mu = 1 - 2 * result

        # Construct Bob's unitary: U = cos(phi)*I - i*mu*sin(phi)*Y, where Y = [[0, -1j],[1j, 0]]
        cos_phi = np.cos(phi)
        sin_phi = np.sin(phi)
        Y = np.array([[0, -1j], [1j, 0]])
        op_single = cos_phi * np.eye(2) - 1j * mu * sin_phi * Y

        # Build full operator acting on the entire system
        ops = [np.eye(2)] * total_qubits
        ops[q2] = op_single

        full_op = ops[0]
        for op in ops[1:]:
            full_op = np.kron(full_op, op)
        return Operator(full_op)

    def create_hamiltonian_terms(self):
        total_qubits = 2 * self.num_batteries
        hamiltonian = {
            "battery_terms": [],  # Local Hamiltonians for each battery
            "coupling_terms": []  # Coupling Hamiltonians between batteries
        }

        # Create battery terms (local Hamiltonians)
        for i in range(self.num_batteries):
            q1, q2 = 2*i, 2*i+1

            # Create Z operators for local terms
            z_ops = []
            for q in [q1, q2]:
                op_list = ['I'] * total_qubits
                op_list[q] = 'Z'
                z_ops.append(''.join(op_list))

            # Create XX operator for interaction term within battery
            op_list = ['I'] * total_qubits
            op_list[q1] = 'X'
            op_list[q2] = 'X'
            xx_op = ''.join(op_list)

            # Identity operator for constant term
            id_op = 'I' * total_qubits

            # Constants based on Hamiltonian (assumed correct)
            z_constant = -2*self.h**2/np.sqrt(self.h**2+self.k**2)
            xx_constant = -2*self.k**2/np.sqrt(self.h**2+self.k**2)

            ops = z_ops + [xx_op, id_op]
            coeffs = [-self.h, -self.h, -2*self.k, z_constant + xx_constant]

            battery_h = self._pauli_string_to_matrix(ops, coeffs, total_qubits)
            hamiltonian["battery_terms"].append(Operator(battery_h))

        # Create coupling terms between batteries
        for i, j in self.network.edges():
            # Connect second qubit of battery i with first qubit of battery j
            q_i = 2*i + 1
            q_j = 2*j

            op_list = ['I'] * total_qubits
            op_list[q_i] = 'X'
            op_list[q_j] = 'X'
            xx_op = ''.join(op_list)

            # This creates the matrix representation of the coupling term with strength -k and stores it in the hamiltonian dictionary with information about which batteries are coupled.
            coupling_h = self._pauli_string_to_matrix([xx_op], [-self.k], total_qubits)
            hamiltonian["coupling_terms"].append({
                "batteries": (i, j),
                "operator": Operator(coupling_h)
            })

        return hamiltonian

    def _pauli_string_to_matrix(self, op_strings, coeffs, num_qubits):
        """Helper to convert Pauli strings to matrices."""
        result = np.zeros((2**num_qubits, 2**num_qubits), dtype=complex)

        for op_string, coeff in zip(op_strings, coeffs):
            op = np.eye(1)
            for c in op_string:
                if c == 'I':
                    op = np.kron(op, np.eye(2))
                elif c == 'X':
                    op = np.kron(op, np.array([[0, 1], [1, 0]]))
                elif c == 'Y':
                    op = np.kron(op, np.array([[0, -1j], [1j, 0]]))
                elif c == 'Z':
                    op = np.kron(op, np.array([[1, 0], [0, -1]]))
            result += coeff * op
        return result

    def _calculate_total_system_energy_raw(self, state):
        hamiltonian = self.create_hamiltonian_terms()

        battery_energies = []
        for battery_h in hamiltonian["battery_terms"]:
            if isinstance(state, DensityMatrix):
                energy = np.real(np.trace(state.data @ battery_h.data))
            else:
                energy = np.real(np.trace(state @ battery_h.data))
            battery_energies.append(energy)

        coupling_energies = []
        for coupling in hamiltonian["coupling_terms"]:
            if isinstance(state, DensityMatrix):
                energy = np.real(np.trace(state.data @ coupling["operator"].data))
            else:
                energy = np.real(np.trace(state @ coupling["operator"].data))
            coupling_energies.append({
                "batteries": coupling["batteries"],
                "energy": energy
            })

        total_energy = sum(battery_energies) + sum(c["energy"] for c in coupling_energies)
        return {
            "total_energy": total_energy,
            "battery_energies": battery_energies,
            "coupling_energies": coupling_energies
        }

    def calculate_total_system_energy(self, state):
        raw_energy = self._calculate_total_system_energy_raw(state)
        shifted_total = raw_energy["total_energy"] - self.reference_energy

        battery_shift = self.reference_energy / self.num_batteries
        shifted_battery_energies = [e - battery_shift for e in raw_energy["battery_energies"]]

        return {
            "total_energy": shifted_total,
            "battery_energies": shifted_battery_energies,
            "coupling_energies": raw_energy["coupling_energies"],
            "raw_total_energy": raw_energy["total_energy"]
        }

    def _calculate_battery_energy_with_couplings_raw(self, state, battery_idx):
        energy_data = self._calculate_total_system_energy_raw(state)
        battery_energy = energy_data["battery_energies"][battery_idx]

        coupling_energy = 0.0
        for coupling in energy_data["coupling_energies"]:
            i, j = coupling["batteries"]
            if i == battery_idx or j == battery_idx:
                coupling_energy += coupling["energy"] / 2
        return battery_energy + coupling_energy

    def calculate_battery_energy_with_couplings(self, state, battery_idx):
        raw_energy = self._calculate_battery_energy_with_couplings_raw(state, battery_idx)
        battery_shift = self.reference_energy / self.num_batteries
        return raw_energy - battery_shift

    def verify_max_energy_state(self):
        max_energy_state = self.prepare_max_energy_state()
        energy_data = self.calculate_total_system_energy(max_energy_state)
        return {
            "max_energy_state_energy": energy_data["total_energy"],
            "battery_energies": energy_data["battery_energies"],
            "coupling_energies": energy_data["coupling_energies"],
            "total_system_energy": energy_data["total_energy"],
            "raw_energy": energy_data["raw_total_energy"]
        }

    def calculate_classical_energy_limit(self):
        ground_state = self.prepare_ground_state()
        ground_energy = self.calculate_total_system_energy(ground_state)["total_energy"]

        max_energy = 0.0  # by definition after shift
        total_extractable = ground_energy - max_energy  # should be negative
        return total_extractable / self.num_batteries

    def generate_teleportation_path(self, topology=None):
        if topology is None and self.network is not None:
            if nx.is_isomorphic(self.network, nx.path_graph(self.num_batteries)):
                topology = 'path'
            elif all(j == 0 or i == 0 for i, j in self.network.edges()):
                topology = 'star'
            elif nx.is_isomorphic(self.network, nx.cycle_graph(self.num_batteries)):
                topology = 'ring'
            else:
                topology = 'custom'

        if topology == 'path':
            return list(range(self.num_batteries))
        elif topology == 'ring':
            path = list(range(self.num_batteries))
            path.append(0)
            return path
        elif topology == 'star':
            path = []
            for i in range(1, self.num_batteries):
                path.append(i)
                path.append(0)
            return path
        else:
            return list(range(self.num_batteries))

    def teleport_energy_network(self, path=None):
        if path is None:
            path = self.generate_teleportation_path()

        if len(path) < 2:
            raise ValueError("Path must contain at least 2 batteries")

        # Verify path connectivity (warning if not connected)
        for i in range(len(path) - 1):
            if path[i+1] not in list(self.network.neighbors(path[i])):
                print(f"Warning: Batteries {path[i]} and {path[i+1]} are not directly connected")

        # Prepare initial maximum energy state (fully charged)
        state = self.prepare_max_energy_state()
        initial_system_energy = self.calculate_total_system_energy(state)
        classical_limit = self.calculate_classical_energy_limit()

        # This code prepares a dictionary to store results and initializes tracking variables.
        # It records the initial energy of each battery, including their share of coupling energies.
        results = {
            "path": path,
            "parameters": {"h": self.h, "k": self.k},
            "steps": [],
            "energy_flow": {
                "total_extracted_by_alice": 0.0,
                "total_extracted_by_bob": 0.0,
                "total_extraction": 0.0,
                "extraction_ratio": 0.0
            },
            "initial_energy": initial_system_energy,
            "quantum_metrics": {},
            "battery_analysis": {}
        }

        initial_battery_energies = {i: self.calculate_battery_energy_with_couplings(state, i)
                                    for i in range(self.num_batteries)}

        total_extracted_alice = 0.0
        total_extracted_bob = 0.0

        # Sequentially perform pairwise operations along the path
        for i in range(len(path) - 1):
            source = path[i]
            target = path[i+1]

            step_results = {
                "source": source,
                "target": target,
                "source_energy_before": initial_battery_energies[source],
                "target_energy_before": initial_battery_energies[target],
                "measurements": {}
            }

            # --- Alice's Measurement (probabilistic) ---
            # Compute probabilities for result 0 and 1
            proj0 = self.alice_measurement_operator(source, 0).data
            proj1 = self.alice_measurement_operator(source, 1).data
            # p = Tr(ρP) where ρ is the state and P is the projection operator.
            p0 = np.real(np.trace(state.data @ proj0))
            p1 = np.real(np.trace(state.data @ proj1))
            # This normalizes the probabilities and randomly selects a measurement outcome based on these probabilities
            total_p = p0 + p1
            if total_p > 0:
                p0 /= total_p
                p1 /= total_p
            else:
                p0, p1 = 0.5, 0.5
            result = np.random.choice([0, 1], p=[p0, p1])

            # Apply Alice's measurement operator
            # The result is normalized to ensure we have a valid density matrix. Then we calculate the energy of the post-measurement state.
            alice_op = self.alice_measurement_operator(source, result)
            post_alice_state_data = alice_op.data @ state.data @ alice_op.data.conj().T
            norm = np.trace(post_alice_state_data)
            if norm < 1e-10:
                continue
            post_alice_state = DensityMatrix(post_alice_state_data / norm)
            post_alice_energy = self.calculate_total_system_energy(post_alice_state)

            # Extraction: use the change in total energy (extraction is defined as ΔE = new - old)
            alice_extracted = post_alice_energy["total_energy"] - initial_system_energy["total_energy"]

            # --- Bob's Operation ---
            bob_op = self.bob_operation_operator(target, result)
            post_bob_state_data = bob_op.data @ post_alice_state.data @ bob_op.data.conj().T
            post_bob_state = DensityMatrix(post_bob_state_data)
            post_bob_energy = self.calculate_total_system_energy(post_bob_state)

            # Bob stored additional energy in his subsystem
            bob_extracted = post_bob_energy["total_energy"] - post_alice_energy["total_energy"]

            # This updates the energy values for all batteries after both Alice and Bob have performed their operations
            final_energy = self.calculate_total_system_energy(post_bob_state)
            final_battery_energies = {j: self.calculate_battery_energy_with_couplings(post_bob_state, j)
                                      for j in range(self.num_batteries)}

            step_results["measurements"][f"result_{result}"] = {
                "probability": p0 if result == 0 else p1,
                "alice_extracted": alice_extracted,
                "bob_extracted": bob_extracted,
                "total_extracted": alice_extracted + bob_extracted,
                "source_energy_after": final_battery_energies[source],
                "target_energy_after": final_battery_energies[target]
            }
            step_results["alice_extracted"] = alice_extracted
            step_results["bob_extracted"] = bob_extracted
            step_results["total_extracted"] = alice_extracted + bob_extracted
            # Define extraction ratio as Bob/Alice in absolute terms (if Alice extraction is nonzero)
            extraction_ratio = abs(bob_extracted / alice_extracted * 100) if abs(alice_extracted) > 1e-10 else 0.0
            step_results["extraction_ratio"] = extraction_ratio

            total_extracted_alice += alice_extracted
            total_extracted_bob += bob_extracted

            # the method updates the system state for the next iteration, making the post-Bob state the new starting point.
            state = post_bob_state
            initial_system_energy = self.calculate_total_system_energy(state)
            initial_battery_energies = final_battery_energies.copy()

            results["steps"].append(step_results)

        final_energy = self.calculate_total_system_energy(state)
        results["final_energy"] = final_energy

        total_extraction = total_extracted_alice + total_extracted_bob
        results["energy_flow"]["total_extracted_by_alice"] = total_extracted_alice
        results["energy_flow"]["total_extracted_by_bob"] = total_extracted_bob
        results["energy_flow"]["total_extraction"] = total_extraction

        extraction_ratio_overall = abs(total_extracted_bob / total_extracted_alice * 100) if abs(total_extracted_alice) > 1e-10 else 0.0
        results["energy_flow"]["extraction_ratio"] = extraction_ratio_overall

        # Energy conservation check: ΔE (final - initial)
        energy_change = final_energy["total_energy"] - results["initial_energy"]["total_energy"]
        expected_energy_change = total_extraction
        results["energy_conservation"] = {
            "initial_total_energy": results["initial_energy"]["total_energy"],
            "final_total_energy": final_energy["total_energy"],
            "measured_energy_change": energy_change,
            "expected_energy_change": expected_energy_change,
            "discrepancy": abs(energy_change - expected_energy_change)
        }

        # Battery-by-battery analysis
        max_energy_state = self.prepare_max_energy_state()
        for i in range(self.num_batteries):
            initial_batt_energy = self.calculate_battery_energy_with_couplings(max_energy_state, i)
            final_batt_energy = self.calculate_battery_energy_with_couplings(state, i)
            extracted_energy = final_batt_energy - initial_batt_energy  # extraction is the change (should be negative)
            abs_extracted_energy = abs(extracted_energy)
            exceeds_classical = abs_extracted_energy > abs(classical_limit)
            quantum_advantage = abs_extracted_energy / abs(classical_limit) if abs(classical_limit) > 0 else 0.0

            results["battery_analysis"][f"battery_{i}"] = {
                "initial_energy": initial_batt_energy,
                "final_energy": final_batt_energy,
                "extracted_energy": extracted_energy,
                "abs_extracted_energy": abs_extracted_energy,
                "classical_limit": classical_limit,
                "exceeds_classical_limit": exceeds_classical,
                "quantum_advantage": quantum_advantage
            }

        return results

    def theoretical_energy_values(self):
        h, k = self.h, self.k

        # Alice's theoretical energy extraction when measuring the maximum energy state
        alice_theoretical_extraction = h**2 / np.sqrt(h**2 + k**2)

        # Calculate optimal angle phi for Bob's energy storage operation
        h2_plus_2k2 = h**2 + 2 * k**2
        h2k2 = h**2 * k**2
        cos_2phi = h2_plus_2k2 / np.sqrt((h2_plus_2k2)**2 + h2k2)
        sin_2phi = h * k / np.sqrt((h2_plus_2k2)**2 + h2k2)
        phi = np.arctan2(sin_2phi, cos_2phi) / 2

        # Bob's theoretical energy storage after Alice's measurement
        bob_theoretical_storage = (1/np.sqrt(h**2 + k**2)) * (h * k * sin_2phi - (h**2 + 2*k**2) * (1 - cos_2phi))

        # Energy teleportation efficiency - how much energy Bob can store relative to Alice's extraction
        # A positive efficiency means Bob stores energy, while a negative value means both extracted energy
        teleportation_efficiency = bob_theoretical_storage / alice_theoretical_extraction * 100

        # Quantum advantage ratio - compares Bob's storage to classical energy density limit
        # This requires calculating the classical limit, which is done in calculate_classical_energy_limit()
        # For the theoretical calculation, we would need to incorporate this

        return {
            "alice_extraction": alice_theoretical_extraction,
            "bob_storage": bob_theoretical_storage,
            "teleportation_efficiency": teleportation_efficiency,
            "optimal_phi_angle": phi
        }

def run_quantum_battery_simulation():
    """
    Run a simulation of quantum batteries on various network topologies.
    """
    print("QUANTUM BATTERY NETWORK SIMULATION")
    print("="*80)

    num_batteries = 4
    qb_network = QuantumBatteryNetwork(num_batteries=num_batteries)

    max_state_verification = qb_network.verify_max_energy_state()
    print(f"\nMaximum Energy State (After Shift):")
    print(f"  Total Energy: {max_state_verification['max_energy_state_energy']:.10f}")
    print(f"  Raw Energy (before shift): {max_state_verification['raw_energy']:.10f}")

    classical_limit = qb_network.calculate_classical_energy_limit()
    print(f"\nClassical Energy Extraction Limit: {classical_limit:.6f} per battery")


    topologies = ['path', 'star', 'ring']
    for topology in topologies:
        print(f"\n\nNETWORK TOPOLOGY: {topology}")
        print("-"*80)
        qb_network.set_network_topology(topology)
        path = qb_network.generate_teleportation_path(topology)
        path_str = '->'.join(map(str, path))
        print(f"Teleportation Path: {path_str}")
        results = qb_network.teleport_energy_network(path)

        print("\nEnergy Extraction Summary:")
        print(f"  Total Energy Extracted by Alice: {results['energy_flow']['total_extracted_by_alice']:.6f}")
        print(f"  Total Energy Extracted by Bob: {results['energy_flow']['total_extracted_by_bob']:.6f}")
        print(f"  Total Energy Extracted: {results['energy_flow']['total_extraction']:.6f}")
        print(f"  Bob/Alice Extraction Ratio: {results['energy_flow']['extraction_ratio']:.2f}%")

        print("\nQuantum Advantage Analysis:")
        for battery, data in results['battery_analysis'].items():
            print(f"  {battery}:")
            print(f"    Initial Energy: {data['initial_energy']:.6f}")
            print(f"    Final Energy: {data['final_energy']:.6f}")
            print(f"    Extracted Energy: {data['extracted_energy']:.6f}")
            print(f"    Extracted Energy (absolute): {data['abs_extracted_energy']:.6f}")
            print(f"    Classical Limit: {data['classical_limit']:.6f}")

        print("\nStep-by-Step Energy Extraction:")
        for i, step in enumerate(results["steps"]):
            print(f"\n  Step {i+1}: Battery {step['source']} -> Battery {step['target']}")
            print(f"    Source Battery Energy Before: {step['source_energy_before']:.6f}")
            print(f"    Target Battery Energy Before: {step['target_energy_before']:.6f}")
            for res_label, data in step["measurements"].items():
                print(f"    Measurement {res_label}:")
                print(f"      Probability: {data['probability']:.6f}")
                print(f"      Alice Extracted Energy: {data['alice_extracted']:.6f}")
                print(f"      Bob Extracted Energy: {data['bob_extracted']:.6f}")
                print(f"      Total Extracted: {data['total_extracted']:.6f}")
                print(f"      Source Battery Energy After: {data['source_energy_after']:.6f}")
                print(f"      Target Battery Energy After: {data['target_energy_after']:.6f}")
            print(f"    Extraction Ratio: {step['extraction_ratio']:.2f}%")

        print("\nEnergy Conservation Check:")
        ec = results["energy_conservation"]
        print(f"  Initial Total Energy: {ec['initial_total_energy']:.10f}")
        print(f"  Final Total Energy: {ec['final_total_energy']:.10f}")
        print(f"  Measured Energy Change: {ec['measured_energy_change']:.10f}")
        print(f"  Expected Energy Change: {ec['expected_energy_change']:.10f}")
        print(f"  Conservation Discrepancy: {ec['discrepancy']:.10f}")

        print("\nQuantum System Analysis:")
        print(f"  Initial System Energy: {results['initial_energy']['total_energy']:.6f}")
        print(f"  Final System Energy: {results['final_energy']['total_energy']:.6f}")

        total_extracted_energy = sum(data['extracted_energy'] for data in results['battery_analysis'].values())
        total_abs_extracted = sum(data['abs_extracted_energy'] for data in results['battery_analysis'].values())
        batteries_exceeding = sum(1 for data in results['battery_analysis'].values() if data['exceeds_classical_limit'])
        print("\nBattery Performance Metrics:")
        print(f"  Total Energy Extracted: {total_extracted_energy:.6f}")
        print(f"  Total Energy Extracted (absolute): {total_abs_extracted:.6f}")
        print(f"  Batteries Exceeding Classical Limit: {batteries_exceeding}/{num_batteries}")

if __name__ == "__main__":
    run_quantum_battery_simulation()

import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit.visualization import plot_circuit_layout
import matplotlib.patches as patches
from matplotlib.collections import PatchCollection
import matplotlib.colors as mcolors
from IPython.display import display, clear_output
import time
from matplotlib.patches import FancyArrowPatch
from matplotlib.path import Path

def visualize_quantum_battery_network(topology='path', num_batteries=4, h=1.0, k=1.0):
    # Create the network based on topology
    if topology == 'path':
        G = nx.path_graph(num_batteries)
        teleportation_path = list(range(num_batteries))
    elif topology == 'star':
        G = nx.star_graph(num_batteries - 1)
        # Create path that alternates between peripheral nodes and hub
        teleportation_path = []
        for i in range(1, num_batteries):
            teleportation_path.append(i)
            teleportation_path.append(0)
        teleportation_path = teleportation_path[:-1]  # Remove last hub visit if not needed
    elif topology == 'ring':
        G = nx.cycle_graph(num_batteries)
        teleportation_path = list(range(num_batteries)) + [0]  # Complete the cycle
    else:
        raise ValueError(f"Unsupported topology: {topology}")

    # Create a figure with two subplots: network graph and quantum circuit
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(20, 10))
    fig.suptitle(f"Quantum Battery Network: {topology.upper()} Topology", fontsize=16)

    # Plot the network graph with battery indices
    pos = None
    if topology == 'path':
        pos = {i: (i, 0) for i in range(num_batteries)}
    elif topology == 'star':
        pos = nx.spring_layout(G, seed=42)
    elif topology == 'ring':
        pos = nx.circular_layout(G)

    # Draw the network
    ax1.set_title("Battery Network Topology")
    nx.draw_networkx(G, pos=pos, ax=ax1, node_color='lightblue', node_size=800, font_size=12)

    # Add labels for each battery
    for node in G.nodes():
        x, y = pos[node]
        ax1.text(x, y-0.15, f"Battery {node}", fontsize=12, ha='center')

    # Highlight the teleportation path with arrows
    edge_colors = []
    edge_weights = []

    # Draw edges with different colors based on teleportation path
    for i in range(len(teleportation_path)-1):
        source = teleportation_path[i]
        target = teleportation_path[i+1]
        # Check if this edge exists in the graph
        if G.has_edge(source, target):
            # Draw a curved arrow for the teleportation path
            ax1.annotate("",
                         xy=pos[target], xycoords='data',
                         xytext=pos[source], textcoords='data',
                         arrowprops=dict(arrowstyle="->", color=f"C{i}",
                                         lw=2, shrinkA=15, shrinkB=15,
                                         connectionstyle="arc3,rad=0.3"))

            # Add step number
            midpoint_x = (pos[source][0] + pos[target][0]) / 2
            midpoint_y = (pos[source][1] + pos[target][1]) / 2
            # Offset the text a bit to account for the curve
            offset_x = (pos[target][1] - pos[source][1]) * 0.1
            offset_y = (pos[source][0] - pos[target][0]) * 0.1
            ax1.text(midpoint_x + offset_x, midpoint_y + offset_y, f"Step {i+1}", fontsize=12, color=f"C{i}")

    # Create a visual representation of the quantum circuit
    ax2.set_title("Quantum Circuit Representation")
    ax2.axis('off')

    # For each battery, we have 2 qubits (Alice and Bob)
    total_qubits = 2 * num_batteries
    qubit_spacing = 0.8

    # Calculate coordinates for each qubit
    qubit_positions = {}
    for b in range(num_batteries):
        alice_qubit = 2 * b
        bob_qubit = 2 * b + 1

        # Place Alice and Bob qubits side by side for each battery
        qubit_positions[alice_qubit] = (0.1, b * qubit_spacing + 0.2)
        qubit_positions[bob_qubit] = (0.3, b * qubit_spacing + 0.2)

    # Draw qubits
    for q, pos in qubit_positions.items():
        battery_idx = q // 2
        is_alice = q % 2 == 0
        color = 'pink' if is_alice else 'lightblue'
        label = f"A{battery_idx}" if is_alice else f"B{battery_idx}"

        # Draw qubit as circle
        circle = plt.Circle(pos, 0.05, color=color, zorder=2)
        ax2.add_patch(circle)

        # Add label
        ax2.text(pos[0], pos[1]-0.1, label, ha='center', fontsize=10, zorder=3)

    # Draw wire lines connecting qubits
    for b in range(num_batteries):
        alice_qubit = 2 * b
        bob_qubit = 2 * b + 1

        # Draw horizontal line connecting Alice and Bob qubits
        alice_pos = qubit_positions[alice_qubit]
        bob_pos = qubit_positions[bob_qubit]
        ax2.plot([alice_pos[0], bob_pos[0]], [alice_pos[1], alice_pos[1]], 'k-', lw=1)

    # Draw the coupling connections based on network topology
    for source, target in G.edges():
        source_bob_qubit = 2 * source + 1
        target_alice_qubit = 2 * target

        source_pos = qubit_positions[source_bob_qubit]
        target_pos = qubit_positions[target_alice_qubit]

        # Draw a curved line representing coupling
        curve = FancyArrowPatch(
            source_pos, target_pos,
            connectionstyle=f"arc3,rad={0.3}",
            arrowstyle='-',
            linestyle='--',
            color='gray',
            alpha=0.6,
            zorder=1
        )
        ax2.add_patch(curve)

    # Visualize teleportation operations
    time_steps = {}
    operation_width = 0.3
    time_pos = 0.5  # Starting x position for operations

    # Label for initial state
    ax2.text(0, -0.3, "|Emax⟩", fontsize=12, ha='center')

    # Draw each step in the teleportation
    for i in range(len(teleportation_path)-1):
        source = teleportation_path[i]
        target = teleportation_path[i+1]

        # Update time position
        time_pos += operation_width * 1.5

        # Alice's measurement (on source battery)
        alice_qubit = 2 * source
        alice_pos = qubit_positions[alice_qubit]

        # Draw measurement box
        meas_rect = patches.Rectangle(
            (time_pos, alice_pos[1]-0.05), operation_width, 0.1,
            linewidth=1, edgecolor='k', facecolor='pink', alpha=0.7, zorder=4
        )
        ax2.add_patch(meas_rect)
        ax2.text(time_pos + operation_width/2, alice_pos[1], "X", ha='center', va='center', fontsize=10, zorder=5)

        # Draw vertical line from measurement to classical channel
        classical_y = -0.5  # Position of classical channel
        ax2.plot([time_pos + operation_width/2, time_pos + operation_width/2],
                 [alice_pos[1]-0.05, classical_y], 'k--', lw=1)

        # Bob's operation (on target battery)
        bob_qubit = 2 * target + 1
        bob_pos = qubit_positions[bob_qubit]

        # Update time position for Bob's operation
        time_pos += operation_width * 1.5

        # Draw operation box
        op_rect = patches.Rectangle(
            (time_pos, bob_pos[1]-0.05), operation_width, 0.1,
            linewidth=1, edgecolor='k', facecolor='lightblue', alpha=0.7, zorder=4
        )
        ax2.add_patch(op_rect)
        ax2.text(time_pos + operation_width/2, bob_pos[1], "U(μ)", ha='center', va='center', fontsize=10, zorder=5)

        # Draw classical channel from Alice to Bob (with arrow)
        ax2.plot([time_pos - operation_width*1.5, time_pos],
                 [classical_y, classical_y], 'k-', lw=1)
        ax2.arrow(time_pos - operation_width*0.3, classical_y,
                  operation_width*0.2, 0, head_width=0.02, head_length=0.02,
                  fc='k', ec='k', zorder=5)

        # Draw vertical line from classical channel to Bob's operation
        ax2.plot([time_pos + operation_width/2, time_pos + operation_width/2],
                 [classical_y, bob_pos[1]-0.05], 'k--', lw=1)

        # Label the step
        ax2.text(time_pos - operation_width*0.75, classical_y-0.1,
                 f"Step {i+1}: B{source}→B{target}", fontsize=10, ha='center')

    # Extend all qubit lines to the end
    max_time = time_pos + operation_width + 0.1
    for q, pos in qubit_positions.items():
        ax2.plot([pos[0], max_time], [pos[1], pos[1]], 'k-', lw=1)

    # Draw the classical communication channel
    ax2.plot([0.5, max_time], [-0.5, -0.5], 'k-', lw=2)
    ax2.text(0.45, -0.5, "Classical Channel", fontsize=10, ha='right', va='center')

    # Add a legend for the circuit
    legend_elements = [
        patches.Patch(facecolor='pink', edgecolor='k', alpha=0.7, label='Alice Measurement'),
        patches.Patch(facecolor='lightblue', edgecolor='k', alpha=0.7, label='Bob Operation'),
        patches.Patch(facecolor='white', edgecolor='gray', alpha=0.6, linestyle='--', label='Coupling')
    ]
    ax2.legend(handles=legend_elements, loc='upper center', bbox_to_anchor=(0.5, -0.6), ncol=3)

    plt.tight_layout()
    plt.show()

    return {
        'topology': topology,
        'teleportation_path': teleportation_path,
        'network': G,
        'hamiltonian_params': {'h': h, 'k': k}
    }

def visualize_all_topologies(num_batteries=4):
    for topology in ['path', 'star', 'ring']:
        print(f"\n{'='*80}\nTopology: {topology.upper()}\n{'='*80}")
        result = visualize_quantum_battery_network(topology, num_batteries)

        # Print details about the teleportation path
        print(f"Teleportation Path: {' -> '.join(map(str, result['teleportation_path']))}")

        # Show connections between batteries
        print("\nBattery Connections:")
        for source, target in result['network'].edges():
            print(f"  Battery {source} <-> Battery {target}")

        # Display some details about Alice's measurements and Bob's operations
        print("\nQuantum Operations:")
        for i in range(len(result['teleportation_path'])-1):
            source = result['teleportation_path'][i]
            target = result['teleportation_path'][i+1]

            # Calculate theoretical values for Bob's operation angles (phi)
            h, k = result['hamiltonian_params']['h'], result['hamiltonian_params']['k']
            h2_plus_2k2 = h**2 + 2 * k**2
            h2k2 = h**2 * k**2
            cos_2phi = h2_plus_2k2 / np.sqrt((h2_plus_2k2)**2 + h2k2)
            sin_2phi = h * k / np.sqrt((h2_plus_2k2)**2 + h2k2)
            phi = np.arctan2(sin_2phi, cos_2phi) / 2

            print(f"  Step {i+1}: Alice measures Battery {source} (X-basis), Bob applies U(φ={phi:.4f}) to Battery {target}")

        print("\n")


# Execute these functions to visualize all topologies
# visualize_all_topologies(4)

# Generate visualization for all three topologies
visualize_all_topologies(4)